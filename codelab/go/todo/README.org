* Todo application

This is a simple to-do application developed using test-driven development and
Copilot. The following milestones were determined ad hoc, so the second
milestone was unknown when the first milestone was being developed.

** Project Structure

The project is organized into several packages:

*** core
Contains the core data structures and business logic for todo items and lists.
Provides functionality for adding, completing, and removing items.

*** config
Handles storage configuration through command-line flags and environment variables.
Supports both JSON and SQLite storage backends.

*** storage/json
Implements JSON file-based storage for todo lists. Uses file system operations
with proper locking mechanisms to ensure thread safety.

*** storage/sqlite
Implements SQLite-based storage for todo lists. Uses SQLite database with proper
locking mechanisms to ensure thread safety and transaction support.

*** main
Contains the command-line interface and defines the storage interface. The
interface is defined here as this is where different storage implementations
are used together.

** Usage

The application provides the following commands:

#+begin_src
todo ls                     List todo items
todo add "item"             Add a new todo item
todo addsubtask <id> "item" Add a subtask to an existing item
todo complete <id>          Complete a todo item
todo uncomplete <id>        Mark a completed item as incomplete
todo undo <id>              Undo a completed item
todo remove <id>            Remove a todo item
#+end_src

Tasks can have subtasks, which are displayed with indentation. The state of a
task is shown as:
- [ ] Not started
- [x] Completed
- [-] Partially done (when some but not all subtasks are completed)

When completing a parent task, all its subtasks will also be completed. When
undoing a task, it and all its subtasks will be marked as not started.

*** Storage Configuration

The storage backend can be configured using either command-line flags or
environment variables:

**** Command-line Flags
- ~--storage-type~: Type of storage backend (json or sqlite)
- ~--storage-path~: Path to the storage file

**** Environment Variables
- ~TODO_STORAGE_TYPE~: Type of storage backend
- ~TODO_STORAGE_PATH~: Path to the storage file

Command-line flags take precedence over environment variables. If neither is
specified, the application defaults to JSON storage at ~/.todo/todos.json.

Examples:
#+begin_src bash
# Use JSON storage with custom path
todo --storage-type json --storage-path /path/to/todos.json ls

# Use SQLite storage with custom path
todo --storage-type sqlite --storage-path /path/to/todos.db ls

# Use environment variables
export TODO_STORAGE_TYPE=sqlite
export TODO_STORAGE_PATH=/path/to/todos.db
todo ls
#+end_src

* Development Status

The application supports both JSON file-based storage and SQLite storage. The
storage interface is defined in the main package where it is used, following
Go's principle of defining interfaces where they are needed.

** DONE Milestone 1
CLOSED: [2025-02-08 Sat 16:52]

It will provide a command-line interface and save it to a file system for
persistence. The ID will be an auto-incrementing integer.

*** DONE Implement todo package
CLOSED: [2025-02-08 Sat 16:13]
+ [X] Last ID
+ [X] Add
+ [X] Complete
+ [X] Delete

*** DONE Implement storage package
CLOSED: [2025-02-08 Sat 16:32]
+ [X] Store
+ [X] Load

*** DONE Command line tool
CLOSED: [2025-02-08 Sat 16:52]

** DONE Milestone 2
CLOSED: [2025-02-08 Sat 19:37]

It will use UUID instead of integer as an ID.

** DONE Milestone 3
CLOSED: [2025-02-09 Sun 13:16]

It will support both the file system and SQLite as storage backends.

*** DONE Planning and task breakdown
CLOSED: [2025-02-09 Sun 12:59]
+ [X] Define main components and their responsibilities
+ [X] Break down implementation into manageable tasks
+ [X] Set clear objectives for each task
+ [X] Document the plan in README.org

*** DONE Design storage interface
CLOSED: [2025-02-09 Sun 13:12]
+ [X] Define storage interface in main.go where it is used
+ [X] Update the existing JSON storage to implement the interface
+ [X] Write interface documentation with clear requirements
+ [X] Update tests to use the interface
+ [X] Ensure all tests pass with the new interface

*** DONE Implement SQLite storage
CLOSED: [2025-02-09 Sun 13:16]
+ [X] Add SQLite dependency (modernc.org/sqlite)
+ [X] Design database schema for todo items
+ [X] Implement SQLite storage that satisfies the storage interface
+ [X] Add error handling and transaction support
+ [X] Write comprehensive tests for SQLite storage
+ [X] Update documentation to reflect SQLite support

*** DONE Configure storage backend
CLOSED: [2025-02-09 Sun 15:36]
+ [X] Define storage backend types (json, sqlite)
+ [X] Add tests for configuration handling
+ [X] Add configuration package to handle storage settings
+ [X] Add command-line flags for storage configuration:
  - --storage-type: Type of storage backend (json, sqlite)
  - --storage-path: Path to the storage file
+ [X] Add environment variable support for storage configuration:
  - TODO_STORAGE_TYPE: Type of storage backend
  - TODO_STORAGE_PATH: Path to the storage file
+ [X] Update main package to use configuration:
  - Create appropriate storage backend based on configuration
  - Handle configuration errors gracefully
  - Provide helpful error messages for invalid configurations
+ [X] Update documentation with configuration options

** TODO Milestone 4

It will support subtasks. Sub tasks can have other subtasks recursively.

*** Design for Recursive Subtasks

To support recursive subtasks, we will implement a tree structure where each
task can have multiple subtasks.

**** Data Model

- **Task Structure**:
  - Each task will have an ID, description, state, and a parent ID.
  - State can be one of: `Not Started`, `Partially Done`, `Done`.
  - The parent ID allows for recursive relationships, enabling tasks to have
    subtasks.

- **JSON Storage**:
  - Use a nested JSON structure where tasks can contain an array of subtasks.
  - Example:
    #+begin_src json
    {
      "id": 1,
      "description": "Parent Task",
      "state": 2,  // Partially Done
      "subtasks": [
        {
          "id": 2,
          "description": "Subtask 1",
          "state": 1  // Done
        },
        {
          "id": 3,
          "description": "Subtask 2",
          "state": 0  // Not Started
        }
      ]
    }
    #+end_src

- **SQLite Storage**:
  - Use a single table with a parent_id column for hierarchical relationships
  - Add a sibling_order column to maintain the order of tasks and subtasks
  - Example schema:
    #+begin_src sql
    CREATE TABLE items (
      id TEXT PRIMARY KEY,
      description TEXT NOT NULL,
      state INTEGER NOT NULL,
      parent_id TEXT REFERENCES items(id),
      sibling_order INTEGER NOT NULL
    );
    #+end_src

  - **State Values**:
    - `0`: Not Started
    - `1`: Done
    - `2`: Partially Done

**** Behavior

- **Task Completion**:
  - When a subtask is marked as done, check if all sibling subtasks are done to
    update the parent task's status to `Done`.
  - If any subtask is not done, the parent task should be `Partially Done`.

- **Parent Task Completion**:
  - When a parent task is marked as done, recursively mark all subtasks as done.

- **Parent Task Undo**:
  - When a parent task is undone, recursively mark all subtasks as not started.

*** Implementation Steps
**** DONE Define Task Structure Updates
CLOSED: [2025-02-09 Sun 16:18]
+ [X] Write tests to verify that tasks can be created with a `parent_id` and
  that the state transitions are correctly handled.
+ [X] Update the core data structures to include a `parent_id` and ensure the
  `state` is an integer.

**** DONE Modify JSON Storage
CLOSED: [2025-02-09 Sun 16:20]
+ [X] Write tests to ensure tasks and subtasks are correctly stored and
  retrieved.
+ [X] Update the JSON storage implementation to handle nested tasks.
+ [X] Implement serialization and deserialization logic for tasks with subtasks.

**** DONE Modify SQLite Storage
CLOSED: [2025-02-09 Sun 16:32]
+ [X] Alter the SQLite schema to include the `parent_id` and use integers for
  the `state`.
+ [X] Run the test to see if the schema change does not break the existing
  tests. Fix the tests if they break.
+ [X] Write tests to verify that tasks and subtasks are correctly stored,
  retrieved, and updated.
+ [X] Implement logic to handle recursive relationships using SQL queries.

**** DONE Implement Task Completion Logic
CLOSED: [2025-02-09 Sun 16:33]
+ [X] Write tests to validate that the task status transitions are correct.
+ [X] Develop logic to update task status based on subtask completion.
+ [X] Ensure marking a parent task as done updates all subtasks.

**** DONE Implement Task Undo Logic
CLOSED: [2025-02-09 Sun 17:00]
+ [X] Write tests to ensure that undoing a task correctly updates all related tasks.
+ [X] Implement the undo functionality for tasks with subtasks.
+ [X] Verify that undoing a parent task undoes all subtasks.
+ [X] Ensure that undoing a subtask correctly updates the parent's state.

**** DONE Update Command-Line Interface
CLOSED: [2025-02-09 Sun 17:15]
+ [X] Write tests to validate the CLI operations.
+ [X] Extend the CLI to support operations on subtasks.
+ [X] Implement commands for adding, completing, and undoing tasks and subtasks.
+ [X] Update task display to show subtasks with proper indentation.
+ [X] Support partial task completion state with [-] indicator.

**** DONE Implement SQLite Ordered Subtasks
CLOSED: [2025-02-09 Sun 19:02]
+ [X] Add sibling_order column to maintain task order
+ [X] Modify Save function to store sibling order
+ [X] Update Load function to preserve task order
+ [X] Add test cases for ordered tasks and subtasks
+ [X] Implement descending UUID generation (ff -> ee -> dd -> cc) for testing
+ [X] Verify order preservation with both ascending and descending IDs

**** TODO Documentation and Review
- [ ] Update the README and any other relevant documentation to reflect the new
  features.
- [ ] Conduct code reviews and refactor as necessary to improve code quality and
  maintainability.

** Milestone 5

Implement additional operations like reordering, indenting and unindenting.

*** How can an SQL table handle ordered items, allowing users to reorder them as they wish?

To handle ordered items in an SQL table and allow users to reorder them, you can
use a column, often called =position= or =order=, to store the sequence value
for each item. Users can change these values to reorder the items. Here's a
basic approach:

1. *Add an =order= column*: Add an integer column to your table to maintain the
   order of the items.

    #+begin_src sql
      ALTER TABLE todos ADD COLUMN position INTEGER;
    #+end_src

2. *Initial assignment*: Assign an initial sequential order to the existing
   items if needed.

    #+begin_src sql
      UPDATE todos SET position = (SELECT COUNT(*) FROM todos t2 WHERE t2.id <= todos.id);
    #+end_src

3. *Reordering*: To reorder items, adjust the =position= values. You might have
   a reorder operation where you set a specific item's position and shift the
   others accordingly.

4. *Handling updates*: When an item's position changes, update the positions of
   other items to maintain a continuous sequence. For example, when moving an
   item to a new position:

    - Shift positions down/up for items between the old and new positions.
    - Set the new position for the moved item.

5. *SQL Example*:

   Suppose you want to move an item from position 5 to position 2:

   #+begin_src sql
     BEGIN;

     -- Increment position for items in the target range
     UPDATE todos
     SET position = position + 1
     WHERE position >= 2 AND position < 5;

     -- Set new position for the moved item
     UPDATE todos
     SET position = 2
     WHERE id = <moved_item_id>;

     COMMIT;
   #+end_src

In an application, you'd likely have a function to handle reordering logic to
ensure consistency and avoid conflicts.
