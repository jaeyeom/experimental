* Todo application

This is a simple to-do application developed using test-driven development and
Copilot. The following milestones were determined ad hoc, so the second
milestone was unknown when the first milestone was being developed.

** Project Structure

The project is organized into several packages:

*** core
Contains the core data structures and business logic for todo items and lists.
Provides functionality for adding, completing, and removing items.

*** storage/json
Implements JSON file-based storage for todo lists. Uses file system operations
with proper locking mechanisms to ensure thread safety.

*** main
Contains the command-line interface and defines the storage interface. The
interface is defined here as this is where different storage implementations
are used together.

** Usage

The application provides the following commands:

#+begin_src
todo ls           List todo items
todo add "item"   Add a new todo item
todo complete id  Complete a todo item
todo uncomplete id  Mark a completed item as incomplete
todo remove id    Remove a todo item
#+end_src

Items are stored in JSON format in ~/.todo/todos.json by default.

* Development Status

The application currently supports JSON file-based storage. The storage interface
has been designed to allow for easy addition of new storage backends. SQLite
support is planned as the next major feature.


** DONE Milestone 1
CLOSED: [2025-02-08 Sat 16:52]

It will provide a command-line interface and save it to a file system for
persistence. The ID will be an auto-incrementing integer.

*** DONE Implement todo package
CLOSED: [2025-02-08 Sat 16:13]
+ [X] Last ID
+ [X] Add
+ [X] Complete
+ [X] Delete

*** DONE Implement storage package
CLOSED: [2025-02-08 Sat 16:32]
+ [X] Store
+ [X] Load

*** DONE Command line tool
CLOSED: [2025-02-08 Sat 16:52]

** DONE Milestone 2
CLOSED: [2025-02-08 Sat 19:37]

It will use UUID instead of integer as an ID.

** DONE Milestone 3
CLOSED: [2025-02-09 Sun 12:59]

It will support both the file system and SQLite as storage backends.

*** DONE Planning and task breakdown
CLOSED: [2025-02-09 Sun 12:59]
+ [X] Define main components and their responsibilities
+ [X] Break down implementation into manageable tasks
+ [X] Set clear objectives for each task
+ [X] Document the plan in README.org

*** DONE Design storage interface
CLOSED: [2025-02-09 Sun 13:12]
+ [X] Define storage interface in main.go where it is used
+ [X] Update the existing JSON storage to implement the interface
+ [X] Write interface documentation with clear requirements
+ [X] Update tests to use the interface
+ [X] Ensure all tests pass with the new interface

*** TODO Implement SQLite storage
+ [ ] Add SQLite dependency
+ [ ] Design database schema for todo items
+ [ ] Implement SQLite storage that satisfies the storage interface
+ [ ] Add error handling and transaction support
+ [ ] Write comprehensive tests for SQLite storage
+ [ ] Update documentation to reflect SQLite support


** TODO Milestone 4

It will support subtasks. Sub tasks can have other substasks recursively.

** Milestone 5

Implement additional operations like reordering, indenting and unindenting.

*** How can an SQL table handle ordered items, allowing users to reorder them as they wish?

To handle ordered items in an SQL table and allow users to reorder them, you can
use a column, often called =position= or =order=, to store the sequence value
for each item. Users can change these values to reorder the items. Here's a
basic approach:

1. *Add an =order= column*: Add an integer column to your table to maintain the
   order of the items.

    #+begin_src sql
      ALTER TABLE todos ADD COLUMN position INTEGER;
    #+end_src

2. *Initial assignment*: Assign an initial sequential order to the existing
   items if needed.

    #+begin_src sql
      UPDATE todos SET position = (SELECT COUNT(*) FROM todos t2 WHERE t2.id <= todos.id);
    #+end_src

3. *Reordering*: To reorder items, adjust the =position= values. You might have
   a reorder operation where you set a specific item's position and shift the
   others accordingly.

4. *Handling updates*: When an item's position changes, update the positions of
   other items to maintain a continuous sequence. For example, when moving an
   item to a new position:

    - Shift positions down/up for items between the old and new positions.
    - Set the new position for the moved item.

5. *SQL Example*:

   Suppose you want to move an item from position 5 to position 2:

   #+begin_src sql
     BEGIN;

     -- Increment position for items in the target range
     UPDATE todos
     SET position = position + 1
     WHERE position >= 2 AND position < 5;

     -- Set new position for the moved item
     UPDATE todos
     SET position = 2
     WHERE id = <moved_item_id>;

     COMMIT;
   #+end_src

In an application, you'd likely have a function to handle reordering logic to
ensure consistency and avoid conflicts.
